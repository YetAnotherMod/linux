/*
 * Device Tree Source for RCM 1888TX018 platform
 *
 * Copyright © 2022 Andrew Andrianov <andrianov@module.ru>
 * Copyright © 2023 Vladislav Fufaev <v.fufaev@modulew.ru>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without
 * any warranty of any kind, whether express or implied.
 */

/include/ "1888tx018.dtsi"

/ {
	model = "rcm,1888tx018";
	compatible = "rcm,1888tx018";

	aliases {
		serial0 = &uart0;
		serial1 = &uart1;
		serial2 = &uart2;
		mmc0 = &mmc0;
	};

	// HDMI channel 1 for DRM drivers
	hdmi-out {
		status = "okay";
		compatible = "hdmi-connector";
		type = "a";

		port {
			hdmi_con: endpoint {
				remote-endpoint = <&adv7513_out>;
			};
		};
	};

	xvclk: xvclk {
		#clock-cells = <0>;
		compatible = "fixed-clock";
		clock-frequency = <24000000>;
	};

	refclk: refclk {
		#clock-cells = <0>;
		compatible = "fixed-clock";
		clock-frequency = <27000000>;
		clock-output-names = "refclk";
	};

	cec: cec {
		#clock-cells = <0>;
		compatible = "fixed-clock";
		clock-frequency = <25000000>;
	};

	vsys_5v: vsys_5v {
		status = "okay";
		compatible = "regulator-fixed";
		regulator-name = "vsys_5v";
		regulator-type = "voltage";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-boot-on;
		enable-active-low;
	};

	regulators {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <0>;

		vbus_usb0: vbus_usb0@0 {
			status = "okay";
			reg = <0>;
			compatible = "regulator-fixed";
			regulator-name = "vbus_usb0";
			regulator-type = "voltage";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			enable-active-low;
			regulator-always-on;
			startup-delay-us = <0>;
			vin-supply = <&vsys_5v>;
			gpio = <&gpio1 5 0>;
		};

		vbus_usb1: vbus_usb1@1 {
			status = "okay";
			reg = <1>;
			compatible = "regulator-fixed";
			regulator-name = "vbus_usb1";
			regulator-type = "voltage";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			enable-active-low;
			regulator-always-on;
			startup-delay-us = <1000000>;
			vin-supply = <&vsys_5v>;
			gpio = <&gpio1 4 0>;
		};

		vbus_usb2: vbus_usb2@2 {
			status = "okay";
			reg = <2>;
			compatible = "regulator-fixed";
			regulator-name = "vbus_usb2";
			regulator-type = "voltage";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			enable-active-low;
			regulator-always-on;
			startup-delay-us = <2000000>;
			vin-supply = <&vsys_5v>;
			gpio = <&gpio1 0 0>;
		};
	};

	plb {

		sram_nor_arbiter {
			status = "ok";
			sram-nor-mux = <0>; // 0 to route extmem wires to LSIF0, 1 - to MCIF
			// in case of LSIF0 following lines will be needed
			ext-mem-mux-mode = <0>; // 0 - SRAN_NOR, 1 - NAND GBIT_GRETH0 GBIT_GRETH1, 2 - GRETH0 GRETH1 NAND
			mii-mux-mode = <0>; // 0- GBIT_GRETH1, 1 - GRETH2
			ce-manage = <2>; // 0
			pinctrl-names = "default";
			pinctrl-0 =
				/* GRETH_GBIT1 -> GMII */
				<&lsif0_mgpio9_greth_gbit1_gmii>,
				<&lsif0_mgpio10_greth_gbit1_gmii>;
				
		};

		lsif0 {
			greth_gbit1: greth_gbit1@0x3C034000 {
				status = "ok";
				mac-address = [ EC 17 66 77 05 02 ];
			};

			lsif0_mgpio0: lsif0_mgpio0@0x3C040420 {
				status = "disabled";
			};

			lsif0_mgpio1: lsif0_mgpio1@0x3C041420 {
				status = "disabled";
			};

			lsif0_mgpio2: lsif0_mgpio2@0x3C042420 {
				status = "disabled";
			};

			lsif0_mgpio3: lsif0_mgpio3@0x3C043420 {
				status = "disabled";
			};

			lsif0_mgpio6: lsif0_mgpio6@0x3C046420 {
				status = "disabled";
			};

			gpio_mgpio0: gpio_mgpio0@0x3C040000 {
				status = "ok";
				#gpio-cells = <2>;
				compatible = "arm,pl061", "arm,primecell";
				gpio-controller;
				reg = <0x3C040000 0x1000>;
				interrupt-controller;
				#interrupt-cells = <2>;
				interrupt-parent = <&MPIC>;
				interrupts = <104 0>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";

				gpioafsel = <0>; //set all GPIO to GPIO mode

				gpio-line-names = "      [mgpio0-0]", "      [mgpio0-1]",
								  "      [mgpio0-2]", "      [mgpio0-3]",
								  "      [mgpio0-4]", "      [mgpio0-5]",
								  "pin15 [mgpio0-6]", "      [mgpio0-7]";

			};

			gpio_mgpio1: gpio_mgpio1@0x3C041000 {
				status = "ok";
				#gpio-cells = <2>;
				compatible = "arm,pl061", "arm,primecell";
				gpio-controller;
				reg = <0x3C041000 0x1000>;
				interrupt-controller;
				#interrupt-cells = <2>;
				interrupt-parent = <&MPIC>;
				interrupts = <110 0>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";

				gpioafsel = <0>; //set all GPIO to GPIO mode

				gpio-line-names = "      [mgpio1-0]", "pin11 [mgpio1-1]",
								  "pin16 [mgpio1-2]", "pin12 [mgpio1-3]",
								  "      [mgpio1-4]", "      [mgpio1-5]",
								  "pin13 [mgpio1-6]", "pin07 [mgpio1-7]";
			};

			gpio_mgpio2: gpio_mgpio2@0x3C042000 {
				status = "ok";
				#gpio-cells = <2>;
				compatible = "arm,pl061", "arm,primecell";
				gpio-controller;
				reg = <0x3C042000 0x1000>;
				interrupt-controller;
				#interrupt-cells = <2>;
				interrupt-parent = <&MPIC>;
				interrupts = <111 0>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";

				gpioafsel = <0>; //set all GPIO to GPIO mode

				gpio-line-names = "pin26 [mgpio2-0]", "pin18 [mgpio2-1]",
								  "pin22 [mgpio2-2]", "pin31 [mgpio2-3]",
								  "pin29 [mgpio2-4]", "pin32 [mgpio2-5]",
								  "pin37 [mgpio2-6]", "      [mgpio2-7]";
			};

			gpio_mgpio3: gpio_mgpio3@0x3C043000 {
				status = "ok";
				#gpio-cells = <2>;
				compatible = "arm,pl061", "arm,primecell";
				gpio-controller;
				reg = <0x3C043000 0x1000>;
				interrupt-controller;
				#interrupt-cells = <2>;
				interrupt-parent = <&MPIC>;
				interrupts = <109 0>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";

				gpioafsel = <0>; //set all GPIO to GPIO mode

				gpio-line-names = "pin24 [mgpio3-0]", "      [mgpio3-1]",
								  "pin36 [mgpio3-2]", "pin33 [mgpio3-3]",
								  "      [mgpio3-4]", "      [mgpio3-5]",
								  "      [mgpio3-6]", "      [mgpio3-7]";
			};

			gpio_mgpio6: gpio_mgpio6@0x3C046000 {
				status = "ok";
				#gpio-cells = <2>;
				compatible = "arm,pl061", "arm,primecell";
				gpio-controller;
				reg = <0x3C046000 0x1000>;
				interrupt-controller;
				#interrupt-cells = <2>;
				interrupt-parent = <&MPIC>;
				interrupts = <113 0>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";

				gpioafsel = <0>; //set all GPIO to GPIO mode

				gpio-line-names = "        [mgpio6-0]", "        [mgpio6-1]",
								  "VIN1_RST[mgpio6-2]", "        [mgpio6-3]",
								  "        [mgpio6-4]", "        [mgpio6-5]",
								  "        [mgpio6-6]", "        [mgpio6-7]";
			};

		};

		lsif1 {
			i2c0: i2c@0x3C05A000 {
				status = "ok";

				hdmi@39 {
					status = "okay";
					compatible = "adi,adv7513";
					reg = <0x39>, <0x29>, <0x49>, <0x59>;
					reg-names = "main", "cec", "edid", "packet";

					adi,input-depth = <8>;
					adi,input-colorspace = "yuv444";
					adi,input-clock = "1x";
					adi,input-style = <1>;
					adi,input-justification = "evenly";

					clocks = <&cec>;
					clock-names = "cec";

					pd-gpios = <&gpio1 2 0>; /* Power Down */

					ports {
						#address-cells = <1>;
						#size-cells = <0>;

						port@0 {
							reg = <0>;
							adv7513_in: endpoint {
								remote-endpoint = <&vdu_out_rgb0>;
							};
						};

						port@1 {
							reg = <1>;
							adv7513_out: endpoint {
								remote-endpoint = <&hdmi_con>;
							};
						};
					};
				};

				ov2640: camera@30 {
					status = "okay";
					compatible = "ovti,ov2640";
					reg = <0x30>;

					clocks = <&xvclk>;
					clock-names = "xvclk";
					assigned-clocks = <&xvclk>;
					assigned-clock-rates = <24000000>;

					resetb-gpios = <&gpio_mgpio6 2 0>;

					port {
						ov2640_0: endpoint {
							remote-endpoint = <&grab_ext_1>;
							bus-type = <5>; /* PARALLEL */
					        bus-width = <8>;
							vsync-active = <1>;
							hsync-active = <1>;
							pclk-sample = <1>;
						};
					};
				};
				imx219: sensor@10 {
					status = "okay";
					compatible = "sony,imx219";
					reg = <0x10>;
					clocks = <&xvclk>;
					clock-names = "xclk";

					//VANA-supply = <&cam1_reg>;      /* 2.8v */
					//VDIG-supply = <&cam_dummy_reg>; /* 1.8v */
					//VDDL-supply = <&cam_dummy_reg>; /* 1.2v */

					rotation = <180>;
					orientation = <2>;

					port {
						/* MIPI CSI-2 bus endpoint */
						imx219_csi2_out: endpoint {
							remote-endpoint = <&tc358748_in>;
							bus-type = <4>; /* CSI2 DPHY */
							clock-lanes = <0>;
							data-lanes = <1 2>;
							//clock-noncontinuous;
							link-frequencies = /bits/ 64 <432000000>;
						};
					};
				};
				// CSI-2 bridge
				csi_bridge: tc358748@e {
					status = "okay";
					compatible = "toshiba,tc358748";
					reg = <0xe>;
					clocks = <&refclk>;
					clock-names = "refclk";
					//vddc-supply = <&v1_2d>;
					//vddio-supply = <&v1_8d>;
					//vddmipi-supply = <&v1_2d>;
					//reset-gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
					mclk-rate = <24000000>;

					ports {
						#address-cells = <1>;
						#size-cells = <0>;

						/* Input */
						port@0 {
							reg = <0>;
							tc358748_in: endpoint {
								remote-endpoint = <&imx219_csi2_out>;
								bus-type = <4>; /* CSI2 DPHY */
								clock-lanes = <0>;
								data-lanes = <1 2>;
								//clock-noncontinuous;
								link-frequencies = /bits/ 64 <432000000>;
							};
						};

						/* Output */
						port@1 {
							reg = <1>;
							tc358748_out: endpoint {
								remote-endpoint = <&grab_ext_0>;
								bus-type = <5>; /* PARALLEL */
								bus-width = <24>;
								hsync-active = <0>;
								vsync-active = <0>;
								data-active = <1>;
								pclk-sample = <1>;
							};
						};
					};
				};
			};

			uart0: uart0@3C05D000 {
				status = "ok";
			};

			uart1: uart2@3C05E000 {
				status = "ok";
			};

			uart2: uart3@3C05F000 {
				status = "ok";
			};

			spi0: spi@0x3C061000 {
				status = "disabled";
				num-cs = <1>;
				cs-gpios = <&gpio1 2 0>;

				spi_flash@0 {
					compatible = "st,m25p32", "spi-nor";
					reg = <0>;
					spi-max-frequency = <20000000>;
				};
			};

			mmc0: mmc0@0x3C064000 {
				status = "ok";
				max-frequency = <25000000>;
				cd-gpios = <&gpio1 1 0>; // card detect
			};

			gpio0: gpio0@0x3C065000 {
				status = "ok";
				gpio-line-names = "SYS_BOOT0", "SYS_BOOT1", "BIST MODE", "HOST MODE",
								  "EDCL LOCK", "SYS_BOOT5", "SYS_BOOT6", "SYS_BOOT7";
			};

			gpio1: gpio1@0x3C066000 {
				status = "ok";
//				gpio-line-names = "SYS_BOOT8", "CARD_DETECT", "HDMI_PD", "USB_VBUS_EN1",
//								  "USB_VBUS_EN2", "USB_VBUS_EN0", "PCIE_M2_RSTn0", "PCIE_M2_RSTn1";
				gpio-line-names = "USB_VBUS_EN2", "CARD_DETECT", "HDMI_PD", "HDMI_INT",
								  "USB_VBUS_EN1", "USB_VBUS_EN0", "PCIE_M2_RSTn0", "PCIE_M2_RSTn1";
			};

			usb_otg_hs: usb_otg_hs@0x3C06D000 {
				status = "ok";
				mode = <1>; // 1 - host, 2 - device
			};
		};

		hsif {
			rmace: rmace@0x3C024000 {
				status = "ok";
				dma-channel-count = <1>;
			};
		};

		mms {
			// VPU for user space driver
			vpu: vpu@0x38020000 {
				status = "ok";
			};

			// VPU for kernel V4L2 driver
			vpu_v4l2: vpu@38020000 {
				status = "disabled";
			};

			jpg: jpg@0x3801a000 {
				status = "ok";
			};

			i2s: i2s@0x39080000 {
				status = "ok";
			};

			i2s0: i2s@0 {
				status = "ok";
			};

			spdif: spdif@0x39080000 {
				status = "ok";
			};

			audio_dma: audio_dma@0x38017000 {
				status = "ok";
			};

			spdif_out: spdif-out {
				#sound-dai-cells = <0>;
				compatible = "linux,spdif-dit";
			};

			audio_dma: audio_dma@0x38017000 {
				status = "ok";
			};

			// HDMI channel 0 for fbdev and v4l2 drivers (actually VDU index 1)
			vdu0: vdu@0x38013000 {
				status = "disabled";
			};

			// HDMI channel 1 for fbdev and v4l2 drivers (actually VDU index 0)
			vdu1: vdu@0x38011000 {
				status = "disabled";
			};

			// HDMI channel 0 for DRM drivers (actually VDU index 1)
			vdu0_drm: vdu@38013000 {
				status = "disabled";
			};

			// HDMI channel 1 for DRM drivers (actually VDU index 0)
			vdu1_drm: vdu@38011000 {
				status = "okay";
				output-color-space = "yuv444";
				max-width = <1280>;
				max-height = <720>;
				ports {
					port@0 {
						vdu_out_rgb0: endpoint@0 {
							remote-endpoint = <&adv7513_in>;
						};
					};
				};
			};

			vdu_graber_ext0: vdu_grabber@0x38016000 {
				status = "okay";
				port {
						grab_ext_0: endpoint {
								remote-endpoint = <&tc358748_out>;
								bus-type = <5>; /* PARALLEL */
								bus-width = <24>;
								vsync-active = <0>;
								hsync-active = <0>;
								data-active = <1>;
								pclk-sample = <1>;
						};
				};
			};

			vdu_graber_ext1: vdu_grabber@0x3801c000 {
				status = "okay";
				port {
						grab_ext_1: endpoint {
								remote-endpoint = <&ov2640_0>;
								bus-type = <5>; /* PARALLEL */
								bus-width = <8>;
								vsync-active = <1>;
								hsync-active = <0>;
								pclk-sample = <1>;
						};
				};
			};

			sound {
				status = "ok";
				compatible = "simple-audio-card";
				simple-audio-card,name = "RCM Audio";
				#address-cells = <1>;
				#size-cells = <0>;
				#sound-dai-cells = <0>;

				simple-audio-card,dai-link@0 { // I2S0 - cs4344
					reg = <0>;
					format = "i2s";
					compatible = "cirrus,cs4344";
					frame-master = <&cpu_dai>;
					bitclock-master = <&cpu_dai>;

					widgets =
						"Line", "Line Out";

					routing =
						"Line Out", "LLOUT",
						"Line Out", "RLOUT";

					cpu_dai: cpu {
						sound-dai = <&i2s0>;
						dai-tdm-slot-num = <2>;
						dai-tdm-slot-width = <32>;
					};

					codec {
						sound-dai = <&codec_dummy>;
					};

				};

				simple-audio-card,dai-link@4 { // spdif
					reg = <4>;
					cpu {
						sound-dai = <&spdif>;
					};
					codec {
						sound-dai = <&spdif_out>;
					};
				};

			};

			codec_dummy: codec_dummy {
				compatible = "linux,snd-soc-dummy";
				#sound-dai-cells = <0>;
				status = "okay";
			};

		};

		apb0 {

			watchdog: watchdog@0x38002000 {
				status = "ok";
			};

			thermal: thermal@0x38003000 {
				status = "ok";
			};

			cpufreq: cpufreq@0x38006000 {
				status = "ok";
				//       freq       fb pre post cpudiv tmrdiv
				freqs = <266667     64  1   1    2      7>,
				        <400000     64  1   1    1      7>,
						<800000     64  1   1    0      7>;

//				freqs = <100000     32  1   2    1      7>,
//						<200000     32  1   1    1      7>,
//						<400000     32  1   1    0      7>,
//						<600000     48  1   1    0      7>,
//						<800000     64  1   1    0      7>;

				/* 50 us (>1000 clocks at refclk/prediv) */
				transition-latency = <50000>; 
			};

		};

		xhsif0 {
			pcie0: pcie@1010000000 {
				status = "ok";
			};
		};

		xhsif1 {
			pcie1: pcie@1018000000 {
				status = "ok";
			};
		};

		dspcores {
			nmc3_0_core0: nmc3_0_core0@0x39000000 {
				status = "ok";
				core-name = "K1879-nmc";
			};
			nmc3_0_core1: nmc3_0_core1@0x39020000 {
				status = "ok";
				core-name = "K1879-nmc";
			};
			nmc3_1_core0: nmc3_1_core0@0x39040000 {
				status = "ok";
				core-name = "K1879-nmc";
			};
			nmc3_1_core1: nmc3_1_core1@0x39060000 {
				status = "ok";
				core-name = "K1879-nmc";
			};
		};
	};

	thermal-zones {
		cpu-thermal {
			polling-delay-passive = <0>;
			polling-delay =  <1000>;
			thermal-sensors = <&thermal>;

			trips {
				cpu-crit {
					temperature = <100000>;
					hysteresis = <0>;
					type = "critical";
				};
			};

			cooling-maps {
			};
		};
	};

	chosen {
		stdout-path = &uart0;
	};
};
